# 数据结构

 ## 线性结构

### 顺序表和链表

每个元素**最多只有一个出度和一个入度**，表现为一条线状。线性表按存储方式分为顺序表和链表。

> 树只能有一个出度，和 n 个入度
>
> 图可以有 n 个出度，和 n 个入度

存储结构：

- 顺序存储：用一组地址连续的存储单元依次存储线性表中的数据元素，使得**逻辑上相邻的元素物理上也相邻**。
- 链式存储：存储各数据元素的结点的地址并不要求是连续的，数据元素**逻辑上相邻，物理上分开**。

> 线性结构反应的是逻辑关系，物理地址不一定相邻
>
> 顺序存储因为物理地址上也相邻，便于定位
>
> 链式存储引用指针，查看下一元素的物理位置    **数据域 | 指针域**

![顺序表链表](./imgs/9.1-顺序表链表.png)

顺序存储和链式存储对比：

| 性能类别 | 具体项目 | 顺序存储                         | 链式存储                             |
| -------- | -------- | -------------------------------- | ------------------------------------ |
| 空间性能 | 存储密度 | =1，更优                         | <1                                   |
|          | 容量分配 | 事先确定                         | 动态改变，更优                       |
| 时间性能 | 查找运算 | O(n/2)                           | O(n/2)                               |
|          | 读运算   | O(1)，更优                       | O([n+1]/2)，最好情况为1，最坏情况为n |
|          | 插入运算 | O(n/2)，最好情况为0，最坏情况为n | O(1)，更优                           |
|          | 删除运算 | O([n-1]/2)                       | O(1)，更优                           |

在空间方面，因为**链表还需要存储指针，因此有空间浪费存在**。（顺序表利用率 100%）

在时间方面，当🔺**需要对元素进行破坏性操作（插入、删除）时，链表效率更高**，因为其只需要修改指针指向即可，而顺序表因为地址是连续的，当删除或插入一个元素后，后面的其他节点位置都需要变动。

> 顺序表每个元素是相邻的，中间没有空余的存储空间了，需要把后面所有的元素整体往后移动，才有空间插入数据
>
> 链表插入数据只需把前一元素指针指向新元素，新元素指针指向后一元素即可

而当需要对元素进行🔺**不改变结构操作时（读取、查找），顺序表效率更高**，因为其物理地址是连续的，如同数组一般只需按索引号就可快速定位，而链表需要从头节点开始，一个个的查找下去。

### 栈和队列

**队列是先进先出**，分队头和队尾；

**栈是先进后出**，只有栈顶能进出。

![栈和队列](./imgs/9.1-栈和队列.png)

#### 循环队列

设循环队列 Q 的容量为 `MAXSIZE`，初始时队列为空，且 `Q.rear` 和 `Q.front` 都等于 0

元素入队时修改队尾指针，即令`Q.rear=(Q.rear+1)%MAXSIZE`

元素出队时修改队头指针，即令`Q.front=(Q.front+1)%MAXSIZE`

> 队头指向第一个元素，是为了读操作
>
> 队尾指针指向最后一个元素的下一个元素，为了写操作，指向空闲区域能直接写

根据队列操作的定义，当出队操作导致队列变为空时，有`Q.rear==Q.front`；

若入队操作导致队列满，则`Q.rear==Q.front`。

![循环队列](./imgs/9.1-循环队列.png)

在队列空和队列满的情况下，循环队列的队头、队尾指针指向的位置是相同的，此时仅仅根据 `Q.rear` 和 `Q.front` 之间的关系无法断定队列的状态。为了区别队空和队满的情况，可采用以下两种处理方式：

其一是设置一个标志，以区别头、尾指针的值相同时队列是空还是满；

其二是**牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满**，如图所示而**头、尾指针的值相同时表示队列为空**。

> `Q.front=(Q.rear+1)%MAXSIZE`

![循环队列2](./imgs/9.1-循环队列2.png)

例：

![顺序栈队列例题](./imgs/9.1-顺序栈队列例题.jpg)

### 串

字符串是一种**特殊的线性表，其数据元素都为字符**。

空串：长度为0的字符串，没有任何字符。

空格串：由**一个或多个空格组成的串**，空格是空白字符，占一个字符长度。

子串：串中**任意长度的连续字符构成的序列称为子串**。含有子串的串称为主串，空串是任意串的子串。

串的模式匹配：子串的定位操作，用于**查找子串在主串中第一次出现的位置的算法**。

#### 模式匹配算法

也称为布鲁特一福斯算法，其基本思想是**从主串的第1个字符起与模式串的第1个字符比较**，若相等，则**继续逐个字符进行后续的比较；否则从主串中的第2个字符起与模式串的第1个字符重新比较**，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功，否则称为匹配失败。

> 写两个循环，从第一个字符开始有一个不匹配；就回退，从第二个字符再开始比，以此类推

![字符串暴力比较法](./imgs/9.2-字符串暴力比较法.gif)

#### KMP 算法

对基本模式匹配算法的改进之处在于：每当匹配过程中出现**相比较的字符不相等时，不需要回溯主串的字符位置指针**，而是利用**已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的距离**，再继续进行比较。

当模式串中的字符`pj`与主串中相应的字符`Si`不相等时，因其前j个字符`("po...pj-1")`已经获得了成功的匹配，所以若模式串中`"p0..pk-1"`与`"pj-k...pj-1"`相同，这时可令`pk`与`Si`进行比较，从而使`i`无须回退。

![KMP](./imgs/9.2-KMP.gif)

在KMP 算法中，依据模式串的next 函数值实现子串的滑动。若令`next[j]=k`，则`next[j]`表示当模式串中的`pj`与主串中相应字符不相等时，令模式串的`next[j]`与主串的相应字符进行比较。

![next](./imgs/9.2-next.gif)

例：

![KPM例题](./imgs/9.2-KMP例题.jpg)

### 数组

数组是**定长线性表在维度上的扩展**，即**线性表中的元素又是一个线性表**。N维数组是一种“同构”的数据结构，其**每个数据元素类型相同、结构一致**。

![数组](./imgs/9.2-数组.png)

其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前驱和一个后继，本质还是线性的。

数组结构的特点：**数据元素数目固定；数据元素类型相同；数据元素的下标关系具有上下界的约束且下标有序。**

数组数据元素固定，一般不做插入和删除运算，**适合于采用顺序结构**。

🔺数组存储地址的计算，特别是二维数组，要注意理解，假设每个数组元素占用存储长度为len，起始地址为a，存储地址计算如下（默认从0开始编号）

（考试的时候取特殊值）

| 数组类型          | 存储地址计算                                                 |
| ----------------- | ------------------------------------------------------------ |
| 一维数组`a[n]`    | `a[i]`的存储地址为：`a + i * len`                            |
| 二维数组`a[m][n]` | `a[i][j]`的存储地址（按行存储）为：`a + (i * n + j) * len` <br/>`a[i][j]`的存储地址（按列存储）为：`a + (j * m + i) * len` |

### 矩阵

特殊矩阵：矩阵中的元素(或非0元素)的分布有定的规律。常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。

稀疏矩阵：在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。

存储方式为三元组结构，即存储每个非零元素的（行，列，值）。

![矩阵](./imgs/9.2-矩阵.png)

例：

![矩阵例题](./imgs/9.2-矩阵例题.jpg)

### 广义表

广义表是线性表的推广，是由**0个或多个单元素或子表组成的有限序列**。

广义表与线性表的区别：**线性表都是结构上不可分的单元素**，而广义线性表的元素**既可以单元素，也可以是有结构的表**。

广义表一般记为：`LS=(a1,a2,…,n)`

其中LS是表名，`ai`是表元素，它可以是表（称为子表），也可以是数据元素（称为原子）。其中n是**广义表的长度（也就是最外层包含的元素个数）**，n=0的广义表为空表；而**递归定义的重数就是广义表的深度，即定义中所含括号的重数**（单边括号的个数，原子的深度为0，空表的深度为1）。

`head()`和`tail()`：**取表头（广义表第一个表元素**，可以是子表也可以是单元素）和**取表尾（广义表中，除了第一个表元素之外的其他所有表元素构成的表**，非空广义表的表尾必定是一个表，即使表尾是单元素）操作。

## 树与二叉树

树是n个节点的有限集合`(n>=0)`，当`n=0`时称为空树，在任一颗非空树中，**有且仅有个根节点**。其余结点可分为**`m(m>=0)`个互不相交的有限子集`T1, T2, ..., Tm`，其中，每个`Ti`又都是一棵树**，并且称为根结点的子树。

树的基本概念如下

- **双亲、孩子和兄弟**。结点的子树的根称为该结点的孩子；相应地，该结点称为其子结点的双亲。**具有相同双亲的结点互为兄弟**。
- **结点的度**。**一个结点的子树的个数**记为该结点的度（只算出度，不算入度）。例如A的度为3，B的度为2，C的度为0，D的度为1。
- **叶子结点**。叶子结点也称为终端结点，指度为0的结点。例如，E、F、C、G都是叶子结点。
- **内部结点**。**度不为0的结点**，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，B、D都是内部结点。
- **结点的层次**。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第i+1层。例如，A在第1层，B、C、D在第2层，E、F和G在第3层。
- **树的高度**。一棵树的**最大层数**记为树的高度(或深度)。例如，图中所示树的高度为3。
- **有序（无序）树**。若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。

![树](./imgs/9.2-树图像.png)

二叉树是n个节点的有限集合它或者是空树，或者是由一个根节点及**两颗互不相交的且分别称为左、右子树的二又树所组成**。

![二叉树](./imgs/9.2-二叉树.png)

**两种特殊的二叉树**如下图所示：

![特殊二叉树](./imgs/9.2-特殊二叉树.png)

> 完全二叉树，假设高度为 k，第 k-1 层是满的，第 k 层从左到右不间断

🔺二叉树有一些性质如下，要求掌握，在实际考试中可以用特殊值法验证。

- 二叉树**第`i`层`(i>=1)`上至多有`2^(i-1)`个节点**（最多就是满二叉树）

- 深度为`k` 的二又树至多有**`2^k-1`个节点**`(k>=1)`（等差数列求和）

- 对任何一棵二叉树，若其**终端节点数为`n0`，度为2 的节点数为`n2`，则`n0=n2+1`**

  > n1 + 2n2 = n0 + n1 + n2 - 1（总的分支数=总结点数-1） --> n0=n2+1

​	此公式可以画一个简单的二又树使用特殊值法快速验证，也可以证明如下设一棵二叉树上**叶结点数为`n0`，单分支结点数为`n1`，双分支结点数为`n2`**，则总结点数=`n0+n1+n2`。在一棵二叉树中，所有结点的分支数（即度数）应等于单分支结点数加上双分支结点数的2倍，即总的分支数=`n1+2n2`，。由于二叉树中除根结点以外每个结点都有唯一的一个分支指向它，因此二叉树中：**总的分支数=总结点数-1**（还有个根节点）。

- 具有**n个节点的完全二叉树的深度为`|log2 n|+ 1`**。（以2为底，n的对数，向下取整）

### 二叉树的存储结构

#### 二叉树的顺序存储结构

顺序存储，就是用一组**连续的存储单元存储二又树中的节点**，按照**从上到下，从左到右的顺序依次存储每个节点**。

对于**深度为k的完全二又树**，除第k层外，其余每层中节点数都是上一层的两倍，由此，从一个节点的编号可推知其双亲、左孩子、右孩子结点的编号。假设有**编号为`i`的节点**，则有：

若**`i=1`，则该节点为根节点**，无双亲；若**`i>1`，则该节点的双亲节点为`|i/2|`**。

若**`2i<=n`，则该节点的左孩子编号为`2i`，否则无左孩子**。

若**`2i+1<=n`，则该节点的右孩子编号为`2i+1`，否则无右孩子**。

显然，顺序存储结构对完全二叉树而言既简单又节省空间，而**对于一般二又树则不适用**。因为在顺序存储结构中，以节点在存储单元中的位置来表示节点之间的关系，那么对于一般的二又树来说，也必须按照完全二又树的形式存储也就是要**添上一些实际并不存在的“虚节点”，这将造成空间的浪费**。

#### 二叉树的链式存储结构

由于二叉树中节点包含有数据元素、左子树根、右子树根及双亲等信息，因此可以用三叉链表或二叉链表（即一个节点含有三个指针或两个指针）来存储二叉树，链表的头指针指向二叉树的根节点

![二叉树链式存储](./imgs/9.3-二叉树链式存储.png)

### 二叉树的遍历

一颗非空的二叉树由根节点、左子树、右子树三部分组成，遍历这三部分也就遍历了整颗二又树。这三部分遍历的**基本顺序是先左子树后右子树，但根节点顺序可变**，以**根节点访问的顺序为准有下列三种遍历方式**：

先序(前序)遍历：根左右。

中序遍历：左根右。

后序遍历：左右根。

层次遍历：按层次，从上到下，从左到右。

反向构造二叉树：仅仅有前序和后序是无法构造二叉树的，**必须要是和中序遍历的集合才能反向构造出二叉树**。

构造时，**前序和后序遍历可以确定根节点，中序遍历用来确定根节点的左子树节点和右子树节点**，而后按此方法进行递归，直至得出结果。



例：

![二叉树例题](./imgs/9.3-二叉树例题.jpg)

### 线索二叉树

引入线索二叉树是为了保存**二叉树遍历时某节点的前驱节点和后继节点的信息**，二叉树的链式存储只能获取到某节点的左孩子和右孩子结点，无法获取其遍历时的前驱和后继节点，因此可以**在链式存储中再增加两个指针域，使其分别指向前驱和后继节点，但这样太浪费存储空间**，考虑下述实现方法：

**若`n`个节点的二叉树使用二叉链表存储，则必然有`n+1`个空指针域**，利用这些空指针域来存放节点的前驱和后继节点信息，为此，需要增加两个标志，以区分指针域存放的到底是孩子结点还是遍历节点，如下：

| ltag | lchild | data | rchild | rtag |
| ---- | ------ | ---- | ------ | ---- |

若二叉树的二叉链表采用上述结构，则称为**线索链表，其中指向前驱、后继节点的指针称为线索**，加上线索的二叉树称为线索二叉树。

>  若`n`个节点的二叉树使用二叉链表存储，则必然有`n+1`个空指针域
>
> ↑
>
> `n`个节点二叉链表存储，一共有`2n`个指针域，没有指针指向根节点，所以用了`n-1`个，空指针域为 `2n-(n+1)=n+1`个

![线索二叉树](./imgs/9.3-线索二叉树.png)

### 🔺 最优二叉树

**最优二叉树又称为哈夫曼树**，是一类带🔺**权路径长度最短的树**，相关概念如下路径：

路径：树中**一个结点到另一个结点之间的通路**。

结点的路径长度：**路径上的分支数目**。

树的路径长度：**根节点到达每一个叶子节点之间的路径长度之和**。

权：节点**代表的值**。

结点的带权路径长度：**该结点到根结点之间的路径长度乘以该节点的权值**。

🔺树的带权路径长度（树的代价）：**树的所有叶子节点的带权路径长度之和**。

![最优二叉树](./imgs/9.3-最优二叉树.png)

哈夫曼树的求法：给出一组权值，将其中**两个最小的权值作为叶子节点，其和作为父节点，组成二叉树，而后删除这两个叶子节点权值，并将父节点的值添加到该组权重中**。重复进行上述步骤，直至所有权值都被使用完。

![哈夫曼树](./imgs/9.3-哈夫曼树.png)

若需要构造**哈夫曼编码**（要保证**左节点值小于右节点的值，才是标准的哈夫曼树**）将标准哈夫曼树的**左分支设为0，右分支设为1**，写出每个叶节点的编码，会发现，哈夫曼编码前缀不同，因此不会混淆，同时也是最优编码。

例：

![哈夫曼树例题](./imgs/9.3-哈夫曼树例题.jpg)

### 🔺查找二叉树

查找二叉树（排序二叉树）上的每个节点都存储一个值，且**每个节点的所有左孩子结点值都小于父节点值，而所有右孩子结点值都大于父节点值**，是一个有规律排列的二叉树，这种数据结构可以方便查找、插入等数据操作。

**二叉排序树的查找效率取决于二叉排序树的深度**，对于结点个数相同的二叉排序树，平衡二叉树的深度最小，而**单枝树的深度是最大的，故效率最差**。

平衡二叉树又称为**AVL树**，它或者是一棵空树，或者是具有下列性质的二叉树它的**左子树和右子树都是平衡二叉树，且左子树和右子树的高度之差的绝对值不超过1**。若将二叉树结点的**平衡因子(Balance Factor，BF)定义为该结点左子树的高度减去其右子树的高度**，则平衡二叉树上所有结点的平衡因子只可能是-1、0和1。只要树上有一个结点的平衡因子的绝对值大于1，则该二叉树就是不平衡的。

![查找二叉树](./imgs/9.3-查找二叉树.png)

例：

![查找二叉树例题](./imgs/9.3-查找二叉树例题.jpg)
