# 数据结构

 ## 线性结构

### 顺序表和链表

每个元素**最多只有一个出度和一个入度**，表现为一条线状。线性表按存储方式分为顺序表和链表。

> 树只能有一个出度，和 n 个入度
>
> 图可以有 n 个出度，和 n 个入度

存储结构：

- 顺序存储：用一组地址连续的存储单元依次存储线性表中的数据元素，使得**逻辑上相邻的元素物理上也相邻**。
- 链式存储：存储各数据元素的结点的地址并不要求是连续的，数据元素**逻辑上相邻，物理上分开**。

> 线性结构反应的是逻辑关系，物理地址不一定相邻
>
> 顺序存储因为物理地址上也相邻，便于定位
>
> 链式存储引用指针，查看下一元素的物理位置    **数据域 | 指针域**

![顺序表链表](./imgs/9.1-顺序表链表.png)

顺序存储和链式存储对比：

| 性能类别 | 具体项目 | 顺序存储                         | 链式存储                             |
| -------- | -------- | -------------------------------- | ------------------------------------ |
| 空间性能 | 存储密度 | =1，更优                         | <1                                   |
|          | 容量分配 | 事先确定                         | 动态改变，更优                       |
| 时间性能 | 查找运算 | O(n/2)                           | O(n/2)                               |
|          | 读运算   | O(1)，更优                       | O([n+1]/2)，最好情况为1，最坏情况为n |
|          | 插入运算 | O(n/2)，最好情况为0，最坏情况为n | O(1)，更优                           |
|          | 删除运算 | O([n-1]/2)                       | O(1)，更优                           |

在空间方面，因为**链表还需要存储指针，因此有空间浪费存在**。（顺序表利用率 100%）

在时间方面，当🔺**需要对元素进行破坏性操作（插入、删除）时，链表效率更高**，因为其只需要修改指针指向即可，而顺序表因为地址是连续的，当删除或插入一个元素后，后面的其他节点位置都需要变动。

> 顺序表每个元素是相邻的，中间没有空余的存储空间了，需要把后面所有的元素整体往后移动，才有空间插入数据
>
> 链表插入数据只需把前一元素指针指向新元素，新元素指针指向后一元素即可

而当需要对元素进行🔺**不改变结构操作时（读取、查找），顺序表效率更高**，因为其物理地址是连续的，如同数组一般只需按索引号就可快速定位，而链表需要从头节点开始，一个个的查找下去。

### 栈和队列

**队列是先进先出**，分队头和队尾；

**栈是先进后出**，只有栈顶能进出。

![栈和队列](./imgs/9.1-栈和队列.png)

#### 循环队列

设循环队列 Q 的容量为 `MAXSIZE`，初始时队列为空，且 `Q.rear` 和 `Q.front` 都等于 0

元素入队时修改队尾指针，即令`Q.rear=(Q.rear+1)%MAXSIZE`

元素出队时修改队头指针，即令`Q.front=(Q.front+1)%MAXSIZE`

> 队头指向第一个元素，是为了读操作
>
> 队尾指针指向最后一个元素的下一个元素，为了写操作，指向空闲区域能直接写

根据队列操作的定义，当出队操作导致队列变为空时，有`Q.rear==Q.front`；

若入队操作导致队列满，则`Q.rear==Q.front`。

![循环队列](./imgs/9.1-循环队列.png)

在队列空和队列满的情况下，循环队列的队头、队尾指针指向的位置是相同的，此时仅仅根据 `Q.rear` 和 `Q.front` 之间的关系无法断定队列的状态。为了区别队空和队满的情况，可采用以下两种处理方式：

其一是设置一个标志，以区别头、尾指针的值相同时队列是空还是满；

其二是**牺牲一个存储单元，约定以“队列的尾指针所指位置的下一个位置是队头指针时”表示队列满**，如图所示而**头、尾指针的值相同时表示队列为空**。

> `Q.front=(Q.rear+1)%MAXSIZE`

![循环队列2](./imgs/9.1-循环队列2.png)

例：

![顺序栈队列例题](./imgs/9.1-顺序栈队列例题.jpg)

### 串

字符串是一种**特殊的线性表，其数据元素都为字符**。

空串：长度为0的字符串，没有任何字符。

空格串：由**一个或多个空格组成的串**，空格是空白字符，占一个字符长度。

子串：串中**任意长度的连续字符构成的序列称为子串**。含有子串的串称为主串，空串是任意串的子串。

串的模式匹配：子串的定位操作，用于**查找子串在主串中第一次出现的位置的算法**。

#### 模式匹配算法

也称为布鲁特一福斯算法，其基本思想是**从主串的第1个字符起与模式串的第1个字符比较**，若相等，则**继续逐个字符进行后续的比较；否则从主串中的第2个字符起与模式串的第1个字符重新比较**，直至模式串中每个字符依次和主串中的一个连续的字符序列相等时为止，此时称为匹配成功，否则称为匹配失败。

> 写两个循环，从第一个字符开始有一个不匹配；就回退，从第二个字符再开始比，以此类推

![字符串暴力比较法](./imgs/9.2-字符串暴力比较法.gif)

#### KMP 算法

对基本模式匹配算法的改进之处在于：每当匹配过程中出现**相比较的字符不相等时，不需要回溯主串的字符位置指针**，而是利用**已经得到的“部分匹配”结果将模式串向右“滑动”尽可能远的距离**，再继续进行比较。

当模式串中的字符`pj`与主串中相应的字符`Si`不相等时，因其前j个字符`("po...pj-1")`已经获得了成功的匹配，所以若模式串中`"p0..pk-1"`与`"pj-k...pj-1"`相同，这时可令`pk`与`Si`进行比较，从而使`i`无须回退。

![KMP](./imgs/9.2-KMP.gif)

在KMP 算法中，依据模式串的next 函数值实现子串的滑动。若令`next[j]=k`，则`next[j]`表示当模式串中的`pj`与主串中相应字符不相等时，令模式串的`next[j]`与主串的相应字符进行比较。

![next](./imgs/9.2-next.gif)

例：

![KPM例题](./imgs/9.2-KMP例题.jpg)

### 数组

数组是**定长线性表在维度上的扩展**，即**线性表中的元素又是一个线性表**。N维数组是一种“同构”的数据结构，其**每个数据元素类型相同、结构一致**。

![数组](./imgs/9.2-数组.png)

其可以表示为行向量形式或者列向量形式线性表，单个关系最多只有一个前驱和一个后继，本质还是线性的。

数组结构的特点：**数据元素数目固定；数据元素类型相同；数据元素的下标关系具有上下界的约束且下标有序。**

数组数据元素固定，一般不做插入和删除运算，**适合于采用顺序结构**。

🔺数组存储地址的计算，特别是二维数组，要注意理解，假设每个数组元素占用存储长度为len，起始地址为a，存储地址计算如下（默认从0开始编号）

（考试的时候取特殊值）

| 数组类型          | 存储地址计算                                                 |
| ----------------- | ------------------------------------------------------------ |
| 一维数组`a[n]`    | `a[i]`的存储地址为：`a + i * len`                            |
| 二维数组`a[m][n]` | `a[i][j]`的存储地址（按行存储）为：`a + (i * n + j) * len` <br/>`a[i][j]`的存储地址（按列存储）为：`a + (j * m + i) * len` |

### 矩阵

特殊矩阵：矩阵中的元素(或非0元素)的分布有定的规律。常见的特殊矩阵有对称矩阵、三角矩阵和对角矩阵。

稀疏矩阵：在一个矩阵中，若非零元素的个数远远少于零元素个数，且非零元素的分布没有规律。

存储方式为三元组结构，即存储每个非零元素的（行，列，值）。

![矩阵](./imgs/9.2-矩阵.png)

例：

![矩阵例题](./imgs/9.2-矩阵例题.jpg)

### 广义表

广义表是线性表的推广，是由**0个或多个单元素或子表组成的有限序列**。

广义表与线性表的区别：**线性表都是结构上不可分的单元素**，而广义线性表的元素**既可以单元素，也可以是有结构的表**。

广义表一般记为：`LS=(a1,a2,…,n)`

其中LS是表名，`ai`是表元素，它可以是表（称为子表），也可以是数据元素（称为原子）。其中n是**广义表的长度（也就是最外层包含的元素个数）**，n=0的广义表为空表；而**递归定义的重数就是广义表的深度，即定义中所含括号的重数**（单边括号的个数，原子的深度为0，空表的深度为1）。

`head()`和`tail()`：**取表头（广义表第一个表元素**，可以是子表也可以是单元素）和**取表尾（广义表中，除了第一个表元素之外的其他所有表元素构成的表**，非空广义表的表尾必定是一个表，即使表尾是单元素）操作。

## 树与二叉树

树是n个节点的有限集合`(n>=0)`，当`n=0`时称为空树，在任一颗非空树中，**有且仅有个根节点**。其余结点可分为**`m(m>=0)`个互不相交的有限子集`T1, T2, ..., Tm`，其中，每个`Ti`又都是一棵树**，并且称为根结点的子树。

树的基本概念如下

- **双亲、孩子和兄弟**。结点的子树的根称为该结点的孩子；相应地，该结点称为其子结点的双亲。**具有相同双亲的结点互为兄弟**。
- **结点的度**。**一个结点的子树的个数**记为该结点的度（只算出度，不算入度）。例如A的度为3，B的度为2，C的度为0，D的度为1。
- **叶子结点**。叶子结点也称为终端结点，指度为0的结点。例如，E、F、C、G都是叶子结点。
- **内部结点**。**度不为0的结点**，也称为分支结点或非终端结点。除根结点以外，分支结点也称为内部结点。例如，B、D都是内部结点。
- **结点的层次**。根为第一层，根的孩子为第二层，依此类推，若某结点在第i层，则其孩子结点在第i+1层。例如，A在第1层，B、C、D在第2层，E、F和G在第3层。
- **树的高度**。一棵树的**最大层数**记为树的高度(或深度)。例如，图中所示树的高度为3。
- **有序（无序）树**。若将树中结点的各子树看成是从左到右具有次序的，即不能交换，则称该树为有序树，否则称为无序树。

![树](./imgs/9.2-树图像.png)

二叉树是n个节点的有限集合它或者是空树，或者是由一个根节点及**两颗互不相交的且分别称为左、右子树的二又树所组成**。

![二叉树](./imgs/9.2-二叉树.png)

**两种特殊的二叉树**如下图所示：

![特殊二叉树](./imgs/9.2-特殊二叉树.png)

> 完全二叉树，假设高度为 k，第 k-1 层是满的，第 k 层从左到右不间断

🔺二叉树有一些性质如下，要求掌握，在实际考试中可以用特殊值法验证。

- 二叉树**第`i`层`(i>=1)`上至多有`2^(i-1)`个节点**（最多就是满二叉树）

- 深度为`k` 的二又树至多有**`2^k-1`个节点**`(k>=1)`（等差数列求和）

- 对任何一棵二叉树，若其**终端节点数为`n0`，度为2 的节点数为`n2`，则`n0=n2+1`**

  > n1 + 2n2 = n0 + n1 + n2 - 1（总的分支数=总结点数-1） --> n0=n2+1

​	此公式可以画一个简单的二又树使用特殊值法快速验证，也可以证明如下设一棵二叉树上**叶结点数为`n0`，单分支结点数为`n1`，双分支结点数为`n2`**，则总结点数=`n0+n1+n2`。在一棵二叉树中，所有结点的分支数（即度数）应等于单分支结点数加上双分支结点数的2倍，即总的分支数=`n1+2n2`，。由于二叉树中除根结点以外每个结点都有唯一的一个分支指向它，因此二叉树中：**总的分支数=总结点数-1**（还有个根节点）。

- 具有**n个节点的完全二叉树的深度为`|log2 n|+ 1`**。（以2为底，n的对数，向下取整）

















