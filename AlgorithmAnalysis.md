# 算法分析与设计

## 算法特性

算法（Algorithm）是**对特定问题求解步骤的一种描述，它是指令的有限序列，其中每一条指令表示一个或多个操作**。此外，一个算法还具有下列 5 个重要特性。

1. 有穷性。一个算法必须总是（对任何合法的输入值）在执行有穷步之后结束，且每一步都可在有穷时间内完成。
2. 确定性。算法中的每一条指令必须有确切的含义，理解时不会产生二义性。并且在任何条件下，算法只有唯一的一条执行路径，即对于相同的输入只能得出相同的输出。
3. 可行性。一个算法是可行的，即算法中描述的操作都可以通过已经实现的基本运算执行有限次来实现。
4. 输入。一个算法**有零个或多个**输入，这些输入取自于某个特定的对象的集合。
5. 输出。一个算法**有一个或多个**输出，这些输出是同输入有着某些特定关系的

## 时间复杂度

算法的时间复杂度分析：主要是**分析算法的运行时间**，即算法**执行所需要的基本操作数。不同规模的输入所需要的基本操作数是不相同**。在算法分析中，**可以建立以输入规模n为自变量的函数T(n)来表示算法的时间复杂度**。 

即使对于**相同的输入规模，数据分布不相同也影响了算法执行路径的不同**，因此所需要的执行时间也不同。根据不同的输入，将算法的时间复杂度分析分为3种情况：最佳情况、最坏情况、平均情况。 

渐进符号：以输入规模n为自变量建立的时间复杂度实际上还是较复杂的，例如`an²+bn+c`，不仅与输入规模有关，还与系数a、b和c有关。此时可以**对该函数做进一步的抽象，仅考虑运行时间的增长率或称为增长的量级**，如忽略上式中的低阶项和高阶项的系数，仅考虑n²。**当输入规模大到只有与运行时间的增长量级有关时，就是在研究算法的渐进效率**。也就是说，**从极限角度看，只关心算法运行时间如何随着输入规模的无限增长而增长**。下面简单介绍3种常用的标准方法来简化算法的渐进分析。 

1. O 记号。定义为：给定一个函数 g (n)，`O (g (n))=f (n)`: 存在正常数 c 和 n0，使得对所有的 n≥n0，有 `0≤f (n)≤g (n)}`，如图（a）所示。**O (g (n)) 表示一个函数集合，往往用该记号给出一个算法运行时间的渐进上界。考试中一般只涉及到 O 符号**。
2. Ω 记号。定义为：给定一个函数 g (n)，`Ω(g (n))=f (n)`: 存在正常数 c 和 n0，使得**对所有的 n≥n0，有 0≤g (n)≤f (n)}**，如图（b）所示。**Ω(g (n)) 表示一个函数集合，往往用该记号给出一个算法运行时间的渐进下界**。
3. Θ 记号。定义为：给定一个函数 g (n)，`Θ(g (n))=f (n)`: 存在正常数 c1、c2 和 n0，使得**对所有的 n≥n0 ，有 `0≤c1g (n)≤f (n)≤c2g (n)`**，如图（c）所示。**Θ(g (n)) 表示一个函数集合，往往用该记号给出一个算法运行时间的渐进上界和渐进下界，即渐进紧致界**。

![算法复杂度](./imgs/10.1-算法复杂度.png)

#### 常数级

```python
sum = 0
n = 100
sum = (1+n)*/2
print(sum)
```

### 平方级

```js
for(const i = 0, i < n, i++) {
    for(const j = 0, j < n, j++) {
        ...
    }
    ...
}

```

#### 线性级

```c
int 1;
for(i = 0; i < n; i++) {
    ...
}
```

### 对数级

> 两两归并，折半查找之类

```c
int count = 1;
while (count < n) {
    count = count * 2;
    ...
}
```

...

## 递归

递归是指**子程序（或函数）直接调用自己**或通过一系列调用语句**间接调用自己**，是一种描述问题和解决问题的常用方法。递归有两个基本要素：**边界条件，即确定递归到何时终止，也称为递归出口；递归模式，即大问题是如何分解为小问题的，也称为递归体**。 

阶乘函数可递归地定义为：

```
n! = { i      , n = 0 // 边界条件，递归结束
	   n(n-1)!, n > 0

```

阶乘函数的自变量n的定义域是非负整数。递归式的**第一式给出了这个函数的一个初始值**，是递归的边界条件。递归式的**第二式是用较小自变量的函数值来表示较大自变量的函数值的方式来定义n的阶乘**，是递归体。n!可以递归地计算如下： 

```c
int Factorial(int num){
    if(num==0) 
         return 1; 
    if(num>0) 
        return num * Factorial(num - 1); 
}
```

递归算法的时间复杂度分析方法：将递归式中**等式右边的项根据递归式进行替换，称为展开**。展开后的项被再次展开，如此下去，直到得到一个求和表达式，得到结果。
下面书上例子有误，应该是 T (n)=T (n - 1)+n

例：求*T*(*n*)={1 (*n*=1); T(n−1)  (n>1) }的解。

解：*T*(*n*)=*T*(*n*−1)+*n*
=*T*(*n*−2)+(*n*−1)+*n*
=⋮
=1+2+⋯+(*n*−1)+*n*
=*n*(*n*+1)/2

![递归列题](./imgs/10.1-递归例题.jpg)

## 分治法

> 归并排序、折半查找...
>
> 子问题互相独立且相同

分治法的设计思想是**将一个难以直接解决的大问题分解成一些规模较小的相同问题**，以便各个击破，分而治之。如果规模为 n 的问题可分解成 k 个子问题，1<k≤n，这些子问题互相独立且与原问题相同。分治法产生的子问题往往是原问题的较小模式，这就为递归技术提供了方便。
一般来说，分治算法在**每一层递归上都有 3 个步骤**。

1. **分解**。将原问题分解成一系列子问题。
2. **求解**。递归地求解各子问题。若子问题足够小则直接求解。
3. **合并**。将子问题的解合并成原问题的解。

凡是涉及到**分组解决**的都是分治法，例如归并排序算法完全依照上述分治算法的 3 个步骤进行。

1. 分解。将 n 个元素分成各含 n/2 个元素的子序列。
2. 求解。用归并排序对两个子序列递归地排序。
3. 合并。合并两个已经排好序的子序列以得到排序结果。

## 动态规划法

> 子问题不一定独立，也不一定相同
>
> 用于求全局最优解，最优子结构

动态规划算法与分治法类似，其**基本思想也是将待求解问题分解成若干个子问题，先求解子问题，然后从这些子问题的解得到原问题的解**。与分治法不同的是，适合用动态规划法求解的问题，**经分解得到的子问题往往不是独立的**。若用分治法来解这类问题，则相同的子问题会被求解多次，以至于最后解决原问题需要耗费指数级时间。

然而，不同子问题的数目常常只有**多项式量级**。如果**能够保存已解决的子问题的答案，在需要时再找出已求得的答案**，这样就可以避免大量的重复计算，从而得到多项式时间的算法。为了达到这个目的，可以用**一个表来记录所有已解决的子问题的答案**。不管该子问题以后是否被用到，**只要它被计算过，就将其结果填入表中**。这就是动态规划法的基本思路。

动态规划算法**通常用于求解具有某种最优性质的问题**。在这类问题中，可能会有许多可行解，每个解都对应于一个值，我们希望找到**具有最优值（最大值或最小值）的那个解**。当然，最优解可能会有多个，动态规划算法能找出其中的一个最优解。设计一个动态规划算法，通常按照以下几个步骤进行。

1. **找出最优解的性质，并刻画其结构特征**：分析最优解具备哪些特性，从结构层面明确其组成等情况，为后续步骤打基础 。比如在背包问题中，要先确定最优装载方案在物品选择组合等方面呈现出的性质。
2. **递归地定义最优解的值**：通过递归的形式来描述最优解的计算方式。像在计算斐波那契数列（可利用动态规划优化）时，用 \(F(n)=F(n - 1)+F(n - 2)\)（\(n>1\)），\(F(0)=0,F(1)=1\) 这样递归定义数列值。 
3. **以自底向上的方式计算出最优值**：从规模最小的子问题开始计算，逐步向上推出更大规模问题的最优值。例如计算斐波那契数列第 \(n\) 项，从最开始的 \(F(0)\) 和 \(F(1)\) 出发，依次算出 \(F(2),F(3),...,F(n)\) 。
4. 根据计算最优值时得到的信息，**构造一个最优解** ：若只需求最优值，此步骤可省；若要得到具体的最优解方案，就需依据前面计算过程留存的信息来构建。比如在任务调度问题中，根据之前计算各阶段任务安排的最优值情况，确定具体的任务执行顺序。

#### 适用动态规划法的问题性质

1. **最优子结构**：若**问题最优解包含子问题最优解**，就具备该性质。如矩阵连乘问题，整个矩阵链相乘的最优计算顺序中，其子矩阵链相乘的顺序也是最优的。此时动态规划可能适用，**但贪心算法也可能可行**。
2.  **重叠子问题**：递归求解原问题时，**反复求解相同子问题，而非不断产生新子问题**。如在计算斐波那契数列中，计算 \(F(n)\) 时，\(F(n - 1)\) 和 \(F(n - 2)\) 会被多次重复计算 ，这就是重叠子问题。 

🔺典型应用：0-1背包问题

有 n 个物品，第 i 个物品**价值为 `vi`，重量为 `wi`**，其中 `vi` 和 `wi` 均为非负数，背包的容量为 W，W 为非负数。现需要考虑如何选择装入背包的物品，使装入背包的物品总价值最大。

满足约束条件的任一集合` (x1, x2, …, xn)` 是问题的一个可行解，问题的目标是要求问题的一个最优解。考虑一个实例，假设 n = 5，W = 17，每个物品的价值和重量如表所示，可将物品 1、2 和 5 装入背包，背包未满，获得价值 22，此时问题解为`（1, 1, 0, 0, 1）`；也可以将物品 4 和 5 装入背包，背包装满，获得价值 24，此时解为`（0, 0, 0, 1, 1）`。

| 物品编号 | 1    | 2    | 3    | 4    | 5    |
| -------- | ---- | ---- | ---- | ---- | ---- |
| 价值 v   | 4    | 5    | 10   | 11   | 13   |
| 重量 w   | 3    | 4    | 7    | 8    | 9    |

1. 刻画 0 - 1 背包问题的最优解的结构。
   可以将背包问题的求解过程看作是进行一系列的决策过程，即**决定哪些物品应该放入背包，哪些物品不放入背包**。如果一个问题的**最优解包含了物品 n**，即 `xn = 1`，那么**其余 `x1, x2, …, xn - 1` 一定构成子问题 `1, 2, …, n - 1` 在容量为 `W - wn` 时的最优解**。如果这个最优解不包含物品 n，即 `xn = 0`，那么**其余 `x1, x2, …, xn - 1` 一定构成子问题 `1, 2, …, n - 1` 在容量为 W 时的最优解**。
2. 递归定义最优解的值。
   根据上述分析的最优解的结构递归地定义问题最优解。设 **c [i, w] 表示背包容量为 w 时 i 个物品导致的最优解的总价值**，得到下式。显然，问题要求 c [n, W]。

![背包问题](./imgs/10.1-背包问题.png)

 